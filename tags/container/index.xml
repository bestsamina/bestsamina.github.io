<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Container on Life &amp; Technological Journey of Samina</title>
    <link>https://bestsamina.github.io/tags/container/</link>
    <description>Recent content in Container on Life &amp; Technological Journey of Samina</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Samina Fu</copyright>
    <lastBuildDate>Mon, 15 Oct 2018 12:05:37 +0800</lastBuildDate>
    
	<atom:link href="https://bestsamina.github.io/tags/container/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>IPVS-based Kube-proxy for Scaled Kubernetes Load Balancing</title>
      <link>https://bestsamina.github.io/posts/2018-10-19-ipvs-based-kube-proxy-4-scaled-k8s-lb/</link>
      <pubDate>Mon, 15 Oct 2018 12:05:37 +0800</pubDate>
      
      <guid>https://bestsamina.github.io/posts/2018-10-19-ipvs-based-kube-proxy-4-scaled-k8s-lb/</guid>
      <description>這篇為 10月19日 talk 的文字版， slides 是 https://speakerdeck.com/sufuf3/ipvs-based-kube-proxy-for-scaled-kubernetes-load-balancing 。
 內容脈絡
 Preface (前言) Introduction (介紹) Kube-Proxy  What is Kube-proxy (什麼是 Kube-proxy) Kube-Proxy mode  IPVS  LVS What is IPVS (什麼是 IPVS) IPVS with Netfilter (IPVS 和 Netfilter) IPVS vs iptables (IPVS 與 iptables 的比較)  IPVS-based Kube-proxy  Why using IPVS? (為什麼要用 IPVS) How IPVS-based Kube-proxy work? (IPVS-based Kube-proxy 是怎麼運作的) Run Kube-proxy in IPVS mode (來執行 IPVS mode 的 Kube-proxy) IPVS Service Network Topology Example  Implement IPVS-based K8s service load balancing (實現 IPVS-based K8s service load balancing) Conclusion (結論)  Preface (前言) 在一般使用 Kubernetes 的 kube-proxy 情況下，通常都使用 iptables 模式。</description>
    </item>
    
    <item>
      <title>實現 IPVS-based K8s service load balancing - 不同 namespace 擁有自己的 external IP</title>
      <link>https://bestsamina.github.io/posts/2018-10-15-hands-on-k8s-kube-proxy-w-ipvs-lb/</link>
      <pubDate>Mon, 15 Oct 2018 11:25:11 +0800</pubDate>
      
      <guid>https://bestsamina.github.io/posts/2018-10-15-hands-on-k8s-kube-proxy-w-ipvs-lb/</guid>
      <description>文章脈絡
 前置作業 環境說明 K8s 於不同 namespace 擁有自己的 external IP 之環境  部署 測試   前置作業 1. 把 IPVS 的 kernel module load 進來 modprobe -- ip_vs modprobe -- ip_vs_rr modprobe -- ip_vs_wrr modprobe -- ip_vs_sh modprobe -- nf_conntrack_ipv4 cut -f1 -d &amp;quot; &amp;quot; /proc/modules | grep -e ip_vs -e nf_conntrack_ipv4  2. 在啟動 kube-proxy 時，參數設為 --proxy-mode=ipvs  (如果要使用其他演算法，那可以設定 --ipvs-scheduler=rr rr 改為其他的)
3. 如果是在 v.10 之前的版本， kube-proxy 要加下面的參數 --feature-gates=SupportIPVSProxyMode=true  4.</description>
    </item>
    
    <item>
      <title>[Kubernetes] 學習筆記</title>
      <link>https://bestsamina.github.io/2018/03/09/kubernetes-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/</link>
      <pubDate>Fri, 09 Mar 2018 14:51:05 +0800</pubDate>
      
      <guid>https://bestsamina.github.io/2018/03/09/kubernetes-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/</guid>
      <description>這是 Kubernetes 相關的學習筆記
 https://github.com/sufuf3/kubernetes-hard-way-deploy https://sufuf3149.gitbooks.io/kubernetes-hard-way-deploy/content/  </description>
    </item>
    
    <item>
      <title>[Build container] Container with Linux Namespace</title>
      <link>https://bestsamina.github.io/posts/2018-01-14-container-linux-namespace/</link>
      <pubDate>Sun, 14 Jan 2018 14:51:05 +0800</pubDate>
      
      <guid>https://bestsamina.github.io/posts/2018-01-14-container-linux-namespace/</guid>
      <description>目錄：
* 前言
* Linux Namespace 類別
* The system calls of namespaces API
* UTS namespaces (CLONE_NEWUTS)
* IPC namespaces (CLONE_NEWIPC)
* PID namespaces (CLONE_NEWPID)
* Mount namespaces (CLONE_NEWNS)
* User namespaces (CLONE_NEWUSER)
* Network namespaces (CLONE_NEWNET)
前言 Linux Namespace 是 Linux Kernel 的其中一個功能，可以隔離對應的系統資源。 關於深入了解 Linux Namespace ，會再另闢一篇來探討。 而這邊就先照著進行，不過為了想法上能夠知道在做什麼，我是套用 C++ 的 Namespace 概念來幫助我先進行實作，讓我透過實際的程式與操作後，而對應到原來這就是 Linux Namespace 以及要怎麼實現。 PS. 建議有一點 OS 概念跟著做會比較好，要不然，最起碼知道 PID 是什麼。
實作環境摘要  Ubuntu 16.04 Kernel version: 4.</description>
    </item>
    
    <item>
      <title>[Build container] Docker 簡介與 Go 環境安裝</title>
      <link>https://bestsamina.github.io/posts/2018-01-03-my-container-setup-env/</link>
      <pubDate>Wed, 03 Jan 2018 14:51:05 +0800</pubDate>
      
      <guid>https://bestsamina.github.io/posts/2018-01-03-my-container-setup-env/</guid>
      <description>Docker 簡介 就軟體的 Docker 來說，Docker 是一個開放原始碼軟體專案。可以讓應用程式佈署在軟體容器下並執行。在 Linix 中， Docker 利用 Linux Kernel 中的資源分離機制，如cgroups, Namespace ，來建立獨立的軟體容器（containers）。 它最早釋出於2013/03/13，原作者為 Solomon Hykes 。 他於 2013 PyCon 的 5 分鐘 lightning talk 中提出 The Future of Linux Containers。 並在 lightning talk 中簡單展示 Docker 的使用方法。
 小小疑惑: 為什麼 go 語言的專案會跑到 PyCon 中發表呢？我覺得比較有關的會是 open source 或是 Linux 相關的 Conference 呢！？
 Docker 擁有的特點有：  輕量化：共享同一台系統的 Kernel 資源，所以可以迅速啟動而且用的 memory 較少。而且 image 是 Filesystem 建制的，所以可以共享相同文件。 open source 標準：可以運行於 Linux distributions 和 Windows OS.</description>
    </item>
    
    <item>
      <title>[Build container] 自己的 Container 自己寫</title>
      <link>https://bestsamina.github.io/2018/01/03/build-container-%E8%87%AA%E5%B7%B1%E7%9A%84-container-%E8%87%AA%E5%B7%B1%E5%AF%AB/</link>
      <pubDate>Wed, 03 Jan 2018 14:51:05 +0800</pubDate>
      
      <guid>https://bestsamina.github.io/2018/01/03/build-container-%E8%87%AA%E5%B7%B1%E7%9A%84-container-%E8%87%AA%E5%B7%B1%E5%AF%AB/</guid>
      <description>手工打造自己的 - mini-container 前言 有在使用 Docker 的人一定對這 Container 的工具不陌生，但身為一個資工人的自己，我開始問自己，那這工具怎麼實作出來的？結果，我完全沒有任何頭緒。看著 docker 或 moby 的程式碼，我完全不知的怎麼下手。 有的只有承認自己是多麼的弱。再想想，我光是期末專題的純手工打造 Mini-filesystem 就已經花了好幾天在看 linux 的 ext2 原始碼。還研究了很久。雖然最後終於從如何切 block 到 inode 到 VFS 到 CLI 一連串的有點貫通後，和隊友一同開發出一個 ext2 的變形 FS 。為了能夠好好的掌握這技術背後是怎麼打造的，這系列，將是我研讀 自己動手寫 Docker 這本書，再加上自己實作與理解的部分，用自己的想法所寫下的紀錄。也希望透過這系列的紀錄，能夠讓自己將這技術儲存在自己的腦袋記憶中。
目錄 1. Docker 簡介與 Go 環境安裝 2. Container with Linux Namespace 3. [(待) 關於 Linux Namespace]() 4. [(待) 關於 Linux Cgroups]() (待續)</description>
    </item>
    
  </channel>
</rss>